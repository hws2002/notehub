Prototype Plan: Building the Graph without an LLMThis document outlines the default policy for creating a knowledge graph from ChatGPT history. The focus here is on a deterministic, rule-based approach suitable for a rapid prototype, without relying on external Large Language Model (LLM) APIs for the initial processing.1. Understanding the Input Data (mock_data.json)The provided JSON data is an array of conversation objects. For our processing, the key path to the text content is consistent:The root is an array [].Each element is a conversation object.Inside each object, the path to messages is: mapping -> [message_id] -> message -> content -> parts -> [0].The actual text is the first element of the parts array. We will process content from messages where the author.role is user or assistant.Example Path to Text: conversation.mapping["de95...."].message.content.parts[0]2. Default Policy: Node CreationNodes will represent the most significant concepts discussed. We will identify them by analyzing word frequency and type.Method: Noun & Noun Phrase FrequencyAggregate Text: Concatenate all text content from parts[0] for every user and assistant message across all conversations into a single large text block.Tokenization: Split the aggregated text into individual words (tokens). Convert all tokens to lowercase to ensure "React" and "react" are treated as the same entity.Stop Word Filtering: Remove common, low-value words (e.g., "the", "a", "is", "in", "it", "you") using a standard stop-word list. This prevents the graph from being cluttered with grammatical noise.Part-of-Speech (POS) Tagging: Use a lightweight client-side JavaScript library (e.g., compromise.js) to analyze the filtered tokens and identify all nouns and noun phrases. This is more effective than just taking all words, as it focuses on things and concepts.Frequency Counting: Count the occurrences of each identified noun and noun phrase.Node Selection: The top 30-50 most frequent nouns/phrases will be selected to become the nodes in our graph. This threshold keeps the initial graph readable.3. Default Policy: Edge CreationEdges represent the relationships between concepts. We will create them based on the principle of co-occurrence.Method: Co-occurrence within a MessageRule: An edge is created between two nodes if their corresponding terms appear within the same message.Process:Iterate through each message (both user and assistant) one by one.For each message, identify which of our selected node-terms are present in its text.If two or more node-terms are found in the same message, create an edge connecting each pair. For example, if a message contains "React," "API," and "JavaScript," we will create three edges: (React, API), (React, JavaScript), and (API, JavaScript).Edge Weight (Optional Enhancement): The strength (or weight) of an edge can be determined by how many times the two concepts co-occur across the entire dataset. For the prototype, all edges can have a uniform weight.4. Step-by-Step Implementation PlanCreate a File Input: Build a simple HTML page with a <input type="file"> element that allows the user to upload their conversations.json file.Parse JSON: Use the JavaScript FileReader API to read the uploaded file and parse it into a JavaScript object.Implement Node Extraction:Write a function that iterates through the parsed JSON, drills down to the message content, and aggregates all the text.Integrate a stop-word list and a POS-tagging library to process the text and generate a frequency-sorted list of nouns.Create a final nodes array from the top N terms. Each node object should have at least an id and a label. (e.g., {id: 1, label: 'React'}).Implement Edge Extraction:Write a second function that iterates through the messages again.In this function, check for the presence of the selected node labels.Create an edges array. Each edge object should connect two nodes by their id. (e.g., {from: 1, to: 2}).Visualize the Graph:Include a graph visualization library like Vis.js or D3.js via a CDN script tag.Pass the generated nodes and edges arrays to the library to render the interactive graph on the page.
